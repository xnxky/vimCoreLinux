package kvstore

import akka.actor.{ OneForOneStrategy, Props, ActorRef, Actor }
import kvstore.Arbiter._
import scala.collection.immutable.Queue
import akka.actor.SupervisorStrategy.Restart
import scala.annotation.tailrec
import akka.pattern.{ ask, pipe }
import akka.actor.Terminated
import scala.concurrent.duration._
import akka.actor.PoisonPill
import akka.actor.OneForOneStrategy
import akka.actor.SupervisorStrategy
import akka.actor.Cancellable
import akka.util.Timeout
import scala.language.postfixOps

object Replica {
  sealed trait Operation {
    def key: String
    def id: Long
  }
  case class Insert(key: String, value: String, id: Long) extends Operation
  case class Remove(key: String, id: Long) extends Operation
  case class Get(key: String, id: Long) extends Operation

  sealed trait OperationReply
  case class OperationAck(id: Long) extends OperationReply
  case class OperationFailed(id: Long) extends OperationReply
  case class GetResult(key: String, valueOption: Option[String], id: Long) extends OperationReply

  def props(arbiter: ActorRef, persistenceProps: Props): Props = Props(new Replica(arbiter, persistenceProps))
}

class Replica(val arbiter: ActorRef, persistenceProps: Props) extends Actor {
  import Replica._
  import Replicator._
  import Persistence._
  import context.dispatcher

  /*
   * The contents of this actor is just a suggestion, you can implement it in any way you like.
   */
  
  var kv = Map.empty[String, String]
  // a map from secondary replicas to replicators
  var secondaries = Map.empty[ActorRef, ActorRef]
  // the current set of replicators
  var replicators = Set.empty[ActorRef]

  var cancellableMap = Map.empty[Long, Cancellable]
  var persistCancellableMap = Map.empty[Long, Cancellable]

  var id2SenderOps = Map.empty[Long, (ActorRef, Operation)]


  var id2ReplicaMap = Map.empty[Long, Set[ActorRef]].withDefaultValue(Set.empty[ActorRef])

  var outstandingPersistOps = Set.empty[String]
  var pendingOperation = Map.empty[String, Queue[Persist]].withDefaultValue(Queue.empty[Persist])
  var persistor2Operation = Map.empty[ActorRef, Persist]
  var failedOperationSet = Set.empty[Long]


  override val supervisorStrategy = OneForOneStrategy(withinTimeRange = 1 seconds) {
    case _:PersistenceException => 
      val op = persistor2Operation(sender)
      persistor2Operation -= sender
      if(failedOperationSet contains op.id)
        failedOperationSet -= op.id
      else
        storeDataInPersistence(op)
      SupervisorStrategy.Stop
  }

  def receive = {
    case JoinedPrimary   => context.become(leader)
    case JoinedSecondary => context.become(replica)
  }

  /* TODO Behavior for  the leader role. */
  val leader: Receive = {
    case Insert(key, value, id) =>
      handleOperations(Some(value), Insert(key, value, id))
    case Remove(key, id) =>
      handleOperations(None, Remove(key, id))
    case Get(key, id) =>
      sender ! GetResult(key, kv.get(key), id)
    case Persisted(key, id) =>
      handlePersistResponse(id)
      prmiaryUpdateKv(id)
      persistNextValue(key, id)
    case Replicated(key, id) =>
      if(id2SenderOps contains id) checkAckCondition(sender, id)
    case Replicas(replicaSet) =>
      handleReplicaChange(replicaSet)
    case OperationFailed(id) =>
      failedOperationSet += id
      id2SenderOps(id)._1 ! OperationFailed(id)
      removeIdFromMaps(id)
  }

  /* TODO Behavior for the replica role. */
  var expectedSeq = 0
  val replica: Receive = {
    case Get(key, id) =>
      sender ! GetResult(key, kv.get(key), id)
    case Persisted(key, seq) =>
      handleSecondaryPersistResponse(key, seq)
    case Snapshot(key, valueOption, seq)=>
      handleSnapshot(key, valueOption, seq)
    case _ =>
  }

  def handleSnapshot(key:String, valueOption:Option[String], seq:Long) {
    if(seq < expectedSeq) 
      sender ! SnapshotAck(key, seq)
    else if (seq == expectedSeq){
      expectedSeq += 1
      val persistOps = Persist(key, valueOption, seq)
      val origOperation = valueOption match {
        case Some(value) =>
          kv += (key -> value)
          Insert(key, value, seq)
        case None => 
          kv -= key
          Remove(key, seq)
      }
      id2SenderOps += (seq -> (sender, origOperation))
      storeDataInPersistence(persistOps)
    }
  }

  def handleOperations(optionValue:Option[String], ops:Operation) {
    id2SenderOps += (ops.id -> (sender, ops))
    val key = ops.key
    val id = ops.id
    cancellableMap += id -> context.system.scheduler.scheduleOnce(1 seconds, self, OperationFailed(id))
    if(outstandingPersistOps contains key) 
      pendingOperation += (key -> (pendingOperation(key) enqueue Persist(key, optionValue, id)))
    else{
      outstandingPersistOps += key
      storeDataInPersistence(Persist(key, optionValue, id))
    }
    replicators foreach ( _ ! Replicate(key, optionValue, id))
  }


  def storeDataInPersistence(persistOps:Persist) {
    val persistActor = context.actorOf(persistenceProps)
    persistor2Operation += (persistActor -> persistOps)
    persistCancellableMap += persistOps.id -> context.system.scheduler.schedule(0 seconds, 100 milliseconds, persistActor, persistOps)
  }

  def handlePersistResponse(id:Long) {
    persistor2Operation -= sender
    context.stop(sender)
  }
  
  def handleSecondaryPersistResponse(key:String, seq:Long){
    handlePersistResponse(seq)
    id2SenderOps(seq)._1 ! SnapshotAck(key, seq)
    id2SenderOps -= seq
    persistCancellableMap(seq).cancel()
    removeIdFromMaps(seq) 
  }
  
  def prmiaryUpdateKv(id:Long){
    val ops = id2SenderOps(id)._2
    ops match{
      case Insert(key, value, id) =>
        kv += (key -> value)
      case Remove(key, id) =>
        kv -= key
      case _ =>
    } 
  }
  
  def persistNextValue(key:String, id:Long) {
    checkAckCondition(self, id)
    if((pendingOperation contains key) && ! pendingOperation(key).isEmpty){
      val (headOps, newQueue) = (pendingOperation(key) dequeue)
      pendingOperation += (key -> newQueue)
      storeDataInPersistence(headOps)
    } else{
      outstandingPersistOps -= key
    }
  }

  def checkAckCondition(readyActor:ActorRef, id:Long) {
     if(id2SenderOps contains id){
      val responsedReplicaSet = id2ReplicaMap(id) | Set(readyActor)
      if( (responsedReplicaSet | replicators | Set(self)) == responsedReplicaSet){
        cancellableMap(id).cancel()
        id2SenderOps(id)._1 ! OperationAck(id)
        removeIdFromMaps(id)
      } else {
        id2ReplicaMap += (id -> responsedReplicaSet)
      }     
    }   
  }

  def removeIdFromMaps(id:Long) {
    cancellableMap -= id
    persistCancellableMap -= id
    id2SenderOps -= id
    id2ReplicaMap -= id
  }

  def handleReplicaChange(replicaSet:Set[ActorRef]){
    val allReplicas = Set(self) | secondaries.keys.toSet
    val newReplicas = replicaSet &~ allReplicas
    val deprecatedReplicas = allReplicas &~ replicaSet
    for {
      leavingReplica <- deprecatedReplicas
      (id, senderOps) <- id2SenderOps
      if(!(id2ReplicaMap(id) contains leavingReplica))
    } checkAckCondition(leavingReplica, id)

    newReplicas foreach {
      oneNewReplica =>
        val newReplicator = context.actorOf(Replicator.props(oneNewReplica))
        secondaries += (oneNewReplica -> newReplicator)
        replicators += newReplicator
        for{
          (key, value) <- kv
        } newReplicator ! Replicate(key, Some(value), -1)
        
        for {
          (key, persistOpsQueue) <- pendingOperation
          Persist(key, valueOption, id) <- persistOpsQueue
        } newReplicator ! Replicate(key, valueOption, id)
    }
  }

  arbiter ! Join
}
